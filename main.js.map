{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","web/js/main.js","node_modules/kivi/lib/dnode.js","node_modules/kivi/lib/env.js","node_modules/kivi/lib/kivi.js","node_modules/kivi/lib/scheduler.js","node_modules/kivi/lib/vdom.js","web/js/app.js","web/js/cache.js","web/js/component/entry.js","web/js/component/main.js","web/js/component/popover.js","web/js/store.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzuCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"main.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nvar INTERVAL = 0;\nvar DATABASE_COUNT = 100;\n\nvar kivi = require('kivi');\nvar Scheduler = require('kivi/lib/scheduler');\n\nvar app = require('./app');\nvar Store = require('./store');\nvar Cache = require('./cache');\nvar Main = require('./component/main');\n\ndocument.addEventListener('DOMContentLoaded', function() {\n  kivi.init(new Scheduler());\n\n  app.store = new Store(DATABASE_COUNT);\n  app.cache = new Cache();\n\n  setInterval(function() {\n    kivi.action(function() {\n      app.store.update();\n    });\n  }, INTERVAL);\n\n  kivi.nextFrame().write(function() {\n    kivi.vdom.injectComponent(kivi.vdom.createComponent(Main), document.body);\n  });\n});","'use strict';\n\nvar ENV = require('./env');\n\nfunction DNode(data) {\n  if (data == null) {\n    this.dirty = true;\n    this.rev = -1;\n    this.data = null;\n  } else {\n    this.dirty = false;\n    this.rev = ENV.scheduler.dataClock;\n    this.data = data;\n  }\n  this.data = data;\n  this.deps = null;\n  this.subs = null;\n  this.invalidated = null;\n  this.ctx = null;\n}\n\nDNode.create = function(data) {\n  if (data === void 0) data = null;\n  return new DNode(data);\n};\n\nDNode.prototype.reset = function() {\n  var deps = this.deps;\n  if (deps != null) {\n    for (var i = 0; i < deps.length; i++) {\n      var dSubs = deps[i].subs;\n      dSubs[dSubs.indexOf(this)] = dSubs[dSubs.length - 1];\n      dSubs.pop();\n    }\n  }\n\n  this.deps = null;\n};\n\nDNode.prototype.sub = function(target) {\n  if (this.deps == null) {\n    this.deps = [];\n  }\n  this.deps.push(target);\n\n  if (target.subs == null) {\n    target.subs = [];\n  }\n  target.subs.push(this);\n};\n\nDNode.prototype.update = function(dirty) {\n  if (dirty) this.rev = ENV.scheduler.dataClock;\n  this.dirty = false;\n};\n\nDNode.prototype.commit = function() {\n  this.rev = ENV.scheduler.dataClock;\n\n  var subs = this.subs;\n  if (subs != null) {\n    for (var i = 0; i < subs.length; i++) {\n      _invalidate(subs[i]);\n    }\n  }\n};\n\nfunction _invalidate(node) {\n  if (!node.dirty) {\n    node.dirty = true;\n\n    if (node.invalidated != null) {\n      node.invalidated.call(node.ctx, node);\n    }\n\n    var subs = node.subs;\n    if (subs != null) {\n      for (var i = 0; i < subs.length; i++) {\n        _invalidate(subs[i]);\n      }\n    }\n\n    node.deps = null;\n    node.subs = null;\n  }\n}\n\nmodule.exports = DNode;\n","'use strict';\n\nvar ENV = {\n  scheduler: null\n};\n\nmodule.exports = ENV;\n","'use strict';\n\nvar ENV = require('./env');\nvar DNode = require('./dnode');\nvar vdom = require('./vdom');\n\nfunction init(scheduler) {\n  ENV.scheduler = scheduler;\n}\n\nfunction nextFrame() {\n  return ENV.scheduler.nextFrame();\n}\n\nfunction scheduleMicrotask(cb) {\n  ENV.scheduler.scheduleMicrotask(cb);\n}\n\nfunction action(cb) {\n  ENV.scheduler.action(cb);\n}\n\nmodule.exports = {\n  ENV: ENV,\n  DNode: DNode,\n  vdom: vdom,\n  init: init,\n  nextFrame: nextFrame,\n  scheduleMicrotask: scheduleMicrotask,\n  action: action\n};\n","'use strict';\n\nfunction _MutationObserverScheduler(cb) {\n  this._observer = new window.MutationObserver(cb);\n  this._node = document.createTextNode('');\n  this._observer.observe(this._node, {characterData: true});\n}\n\n_MutationObserverScheduler.prototype.requestNextTick = function() {\n  this._toggle ^= 1;\n  this._node.data = this._toggle;\n};\n\nvar F_WRITE_PRIO = 4;\nvar F_WRITE = 8;\nvar F_READ = 16;\nvar F_AFTER = 32;\nvar F_WRITE_ANY = F_WRITE | F_WRITE_PRIO;\n\nfunction Frame() {\n  this.flags = 0|0;\n  this.writeTaskGroups = [];\n  this.writeTasks = null;\n  this.readTasks = null;\n  this.afterTasks = null;\n}\n\nFrame.prototype.write = function(cb, priority) {\n  var group;\n\n  if (priority === void 0) priority = -1;\n\n  if (priority === -1) {\n    this.flags |= F_WRITE;\n    if (this.writeTasks == null) {\n      this.writeTasks = [];\n    }\n    this.writeTasks.push(cb);\n  } else {\n    this.flags |= F_WRITE_PRIO;\n    while (priority >= this.writeTaskGroups.length) {\n      this.writeTaskGroups.push(null);\n    }\n\n    group = this.writeTaskGroups[priority];\n    if (group == null) {\n      group = this.writeTaskGroups[priority] = [];\n    }\n\n    group.push(cb);\n  }\n};\n\nFrame.prototype.read = function(cb) {\n  this.flags |= F_READ;\n  if (this.readTasks == null) {\n    this.readTasks = [];\n  }\n  this.readTasks.push(cb);\n};\n\nFrame.prototype.after = function(cb) {\n  this.flags |= F_AFTER;\n  if (this.afterTasks == null) {\n    this.afterTasks = [];\n  }\n  this.afterTasks.push(cb);\n};\n\nvar S_RUNNING = 1;\nvar S_MICROTASK_PENDING = 2;\nvar S_FRAMETASK_PENDING = 4;\n\nfunction Scheduler() {\n  this.flags = 0|0;\n  this.dataClock = 0;\n  this.clock = -1;\n\n  this._actions = null;\n\n  this._microtasks = null;\n  this._currentFrame = new Frame();\n  this._nextFrame = new Frame();\n\n  var self = this;\n\n  this._microtaskScheduler = new _MutationObserverScheduler(function() {\n    self.flags &= ~S_MICROTASK_PENDING;\n    self.flags |= S_RUNNING;\n    self.clock++;\n\n    var tasks = self._microtasks;\n    if (tasks != null) {\n      self._microtasks = null;\n\n      for (var i = 0; i < tasks.length; i++) {\n        tasks[i]();\n      }\n    }\n\n    self.dataClock++;\n    self.performActions();\n    self.flags &= ~S_RUNNING;\n  });\n\n  this._handleAnimationFrame = function() {\n    var frame;\n    var groups;\n    var group;\n    var task;\n    var i, j;\n\n    self.flags &= ~S_FRAMETASK_PENDING;\n    self.flags |= S_RUNNING;\n    self.clock++;\n\n    frame = self._nextFrame;\n    self._nextFrame = self._currentFrame;\n    self._currentFrame = frame;\n\n    do {\n      while ((frame.flags & F_WRITE_ANY) !== 0) {\n        if ((frame.flags & F_WRITE_PRIO) !== 0) {\n          frame.flags &= ~F_WRITE_PRIO;\n          groups = frame.writeTaskGroups;\n\n          for (i = 0; i < groups.length; i++) {\n            group = groups[i];\n            if (group != null) {\n              groups[i] = null;\n              for (j = 0; j < group.length; j++) {\n                task = group[j];\n                task();\n              }\n            }\n          }\n        }\n\n        if ((frame.flags & F_WRITE) !== 0) {\n          frame.flags &= ~F_WRITE;\n          group = frame.writeTasks;\n          for (i = 0; i < group.length; i++) {\n            task = group[i];\n            task();\n          }\n        }\n      }\n\n      while ((frame.flags & F_READ) !== 0) {\n        frame.flags &= ~F_READ;\n        group = frame.readTasks;\n        frame.readTasks = null;\n\n        for (i = 0; i < group.length; i++) {\n          task = group[i];\n          task();\n        }\n      }\n    } while ((frame.flags & F_WRITE_ANY) !== 0);\n\n    while ((frame.flags & F_AFTER) !== 0) {\n      frame.flags &= ~F_AFTER;\n\n      group = frame.afterTasks;\n      for (i = 0; i < group.length; i++) {\n        task = group[i];\n        task();\n      }\n    }\n\n    self.dataClock++;\n    self.performActions();\n    self.flags &= ~S_RUNNING;\n  };\n};\n\nScheduler.prototype.currentFrame = function() {\n  return this._currentFrame;\n};\n\nScheduler.prototype.nextFrame = function() {\n  if ((this.flags & S_FRAMETASK_PENDING) === 0) {\n    this.flags |= S_FRAMETASK_PENDING;\n    window.requestAnimationFrame(this._handleAnimationFrame);\n  }\n  return this._nextFrame;\n};\n\nScheduler.prototype.scheduleMicrotask = function(cb) {\n  if ((this.flags & S_MICROTASK_PENDING) === 0) {\n    this.flags |= S_MICROTASK_PENDING;\n    this._microtaskScheduler.requestNextTick();\n  }\n\n  if (this._microtasks == null) {\n    this._microtasks = [];\n  }\n\n  this._microtasks.push(cb);\n};\n\nScheduler.prototype.action = function(cb) {\n  if ((this.flags & S_MICROTASK_PENDING) === 0) {\n    this.flags |= S_MICROTASK_PENDING;\n    this._microtaskScheduler.requestNextTick();\n  }\n\n  if (this._actions == null) {\n    this._actions = [];\n  }\n\n  this._actions.push(cb);\n};\n\nScheduler.prototype.performActions = function() {\n  while (this._actions != null) {\n    var actions = this._actions;\n    this._actions = null;\n    for (var i = 0; i < actions.length; i++) {\n      actions[i]();\n    }\n  }\n};\n\nmodule.exports = Scheduler;\n","'use strict';\n\nvar DNode = require('./dnode');\nvar ENV = require('./env');\n\nvar V_TEXT = 1;\nvar V_ELEMENT = 2;\nvar V_CUSTOM_ELEMENT = 4;\nvar V_COMPONENT = 8;\nvar V_ROOT = 16;\nvar V_SVG = 64;\n\n/**\n * Virtual Node.\n *\n * @param flags Flags.\n * @param key Key that should be unique among its siblings. If the key\n *   is null, it means that the key is implicit.\n * @param tag When the VNode is Element tag represents its tagName,\n *   and when VNode is a Component it is a ComponentFactory.\n * @param data\n * @constructor\n */\nfunction VNode(flags, key, tag, data) {\n  this.flags = flags;\n  this.key = key;\n  this.tag = tag;\n  this.data = data;\n  this.type = null;\n  this.attrs = null;\n  this.style = null;\n  this.classes = null;\n  this.children = null;\n  this.ref = null;\n  this.cref = null;\n}\n\nVNode.TEXT = V_TEXT;\nVNode.ELEMENT = V_ELEMENT;\nVNode.CUSTOM_ELEMENT = V_CUSTOM_ELEMENT;\nVNode.COMPONENT = V_COMPONENT;\nVNode.ROOT = V_ROOT;\n\nfunction text(content) {\n  return new VNode(V_TEXT, null, null, content);\n};\n\nfunction $text(key, content) {\n  return new VNode(V_TEXT, key, null, content);\n};\n\nfunction element(tag) {\n  return new VNode(V_ELEMENT, null, tag, null);\n};\n\nfunction $element(key, tag) {\n  return new VNode(V_ELEMENT, key, tag, null);\n};\n\nfunction customElement(tag, data) {\n  if (data === void 0) data = null;\n  return new VNode(V_CUSTOM_ELEMENT, null, tag, data);\n};\n\nfunction $customElement(key, tag, data) {\n  if (data === void 0) data = null;\n  return new VNode(V_ELEMENT, key, tag, data);\n};\n\nfunction svg(tag) {\n  return new VNode(V_ELEMENT | V_SVG, null, tag, null);\n};\n\nfunction $svg(key, tag) {\n  return new VNode(V_ELEMENT | V_SVG, key, tag, null);\n};\n\nfunction component(descriptor, data) {\n  if (data === void 0) data = null;\n  return new VNode(V_COMPONENT, null, descriptor, data);\n};\n\nfunction $component(key, descriptor, data) {\n  if (data === void 0) data = null;\n  return new VNode(V_COMPONENT, key, descriptor, data);\n};\n\nfunction root() {\n  return new VNode(V_ROOT, null, null, null);\n};\n\n/**\n * Checks if two VNodes have the same type and they can be updated.\n */\nfunction sameType(a, b) {\n  return (a.flags === b.flags && a.tag === b.tag);\n}\n\n/**\n * Create internal state of the VNode.\n */\nfunction create(node, context) {\n  var flags = node.flags;\n\n  if ((flags & V_TEXT) !== 0) {\n    node.ref = document.createTextNode(node.data);\n  } else if ((flags & V_ELEMENT) !== 0) {\n    if ((flags & V_SVG) === 0) {\n      node.ref = document.createElement(node.tag);\n    } else {\n      node.ref = document.createElementNS('http://www.w3.org/2000/svg', node.tag);\n    }\n  } else if ((flags & V_CUSTOM_ELEMENT) !== 0) {\n    node.ref = createElement(node.tag, node.data);\n  } else if ((flags & V_COMPONENT) !== 0) {\n    var component = createComponent(node.tag, node.data, context);\n    node.ref = component.element;\n    node.cref = component;\n  }\n};\n\n/**\n * Render internal representation of the VNode.\n */\nfunction render(node, context) {\n  var i, il;\n  var key;\n  var flags = node.flags;\n\n  if ((flags & (V_ELEMENT | V_CUSTOM_ELEMENT | V_COMPONENT | V_ROOT)) !== 0) {\n    var ref = node.ref;\n    var nodeType = node.type;\n    var nodeAttrs = node.attrs;\n    var nodeStyle = node.style;\n    var nodeClasses = node.classes;\n    var nodeChildren = node.children;\n\n    if (nodeType != null) {\n      ref.classList.add(nodeType);\n    }\n\n    if (nodeAttrs != null) {\n      for (key in nodeAttrs) {\n        ref.setAttribute(key, nodeAttrs[key]);\n      }\n    }\n\n    if (nodeStyle != null) {\n      var style = ref.style;\n\n      for (key in nodeStyle) {\n        style.setProperty(key, nodeStyle[key]);\n      }\n    }\n\n    if (nodeClasses != null) {\n      var classList = ref.classList;\n\n      for (i = 0, il = nodeClasses.length; i < il; i++) {\n        classList.add(nodeClasses[i]);\n      }\n    }\n\n    if (nodeChildren != null) {\n      for (i = 0, il = nodeChildren.length; i < il; i++) {\n        insertChild(node, nodeChildren[i], null, context);\n      }\n    }\n\n    if ((flags & V_COMPONENT) !== 0) {\n      node.cref.update();\n    }\n  }\n};\n\n/**\n * Update VNode. When VNode a is updated with VNode b, VNode a should\n * be considered as destroyed, and any access to it is an undefined\n * behaviour.\n *\n * @param {!VNode} a Old VNode\n * @param {!VNode} b New VNode\n * @param {Context} context\n */\nfunction update(a, b, context) {\n  var ref = a.ref;\n  var flags = a.flags;\n  b.ref = ref;\n\n  if ((flags & V_TEXT) !== 0) {\n    if (a.data != b.data) {\n      a.ref.nodeValue = b.data; // nodeValue\n    }\n\n  } else if ((flags & (V_ELEMENT | V_CUSTOM_ELEMENT | V_COMPONENT | V_ROOT)) !== 0) {\n    // No need to update type class, because it should be immutable.\n\n    if (a.attrs !== b.attrs) {\n      updateAttrs(a.attrs, b.attrs, ref.attributes);\n    }\n    if (a.style !== b.style) {\n      updateStyle(a.style, b.style, ref.style);\n    }\n    if (a.classes !== b.classes) {\n      updateClasses(a.classes, b.classes, ref.classList);\n    }\n    if (a.children !== b.children) {\n      updateChildren(a, a.children, b.children, context);\n    }\n\n    if ((flags & V_CUSTOM_ELEMENT) !== 0) {\n      var descriptor = b.tag;\n      if ((descriptor.flags & E_UPDATE_HOOK) !== 0) {\n        descriptor.update.call(ref, a.data, b.data);\n      }\n    } else if ((flags & V_COMPONENT) !== 0) {\n      var component = b.cref = a.cref;\n      var state = component.state;\n\n      component.updateProps(b.data);\n      component.update();\n    }\n  }\n};\n\n/**\n * Update HTMLElement attributes.\n *\n * @param a Old attributes.\n * @param b New attributes.\n * @param attributes\n */\nfunction updateAttrs(a, b, attributes) {\n  var key;\n  var aValue;\n  var bValue;\n\n  if (a != null) {\n    if (b == null) {\n      // b is empty, remove all attributes from a.\n      for (key in a) {\n        attributes.removeNamedItem(key);\n      }\n    } else {\n      // Remove and update attributes.\n      for (key in a) {\n        bValue = b[key];\n        if (bValue === void 0) {\n          attributes.removeNamedItem(key);\n        } else {\n          aValue = a[key];\n          if (aValue !== bValue) {\n            attributes.setNamedItem(key, bValue);\n          }\n        }\n      }\n\n      // Insert new attributes.\n      for (key in b) {\n        aValue = a[key];\n        if (aValue === void 0) {\n          attributes.setNamedItem(key, aValue);\n        }\n      }\n    }\n  } else if (b != null) {\n    // a is empty, insert all attributes from b.\n    for (key in b) {\n      attributes.setNamedItem(key, b[key]);\n    }\n  }\n}\n\n/**\n * Update HTMLElement styles.\n *\n * @param {Object.<string,string>} a Old style.\n * @param {Object.<string,string>} b New style.\n * @param {CSSStyleDeclaration} style\n */\nfunction updateStyle(a, b, style) {\n  var key;\n  var value;\n\n  if (a != null) {\n    if (b == null) {\n      // b is empty, remove all styles from a.\n      for (key in a) {\n        style.removeProperty(key);\n      }\n    } else {\n      // Remove and update styles.\n      for (key in a) {\n        value = b[key];\n        if (value === void 0) {\n          style.removeProperty(key);\n        } else {\n          style.setProperty(key, value);\n        }\n      }\n\n      // Insert new styles.\n      for (key in b) {\n        value = a[key];\n        if (value === void 0) {\n          style.setProperty(key, b[key]);\n        }\n      }\n    }\n  } else if (b != null) {\n    // a is empty, insert all styles from b.\n    for (key in b) {\n      style.setProperty(key, b[key]);\n    }\n  }\n}\n\n/**\n * Update HTMLElement classes.\n *\n * @param {Array.<string>} a Old classes.\n * @param {Array.<string>} b New classes.\n * @param {DOMTokenList} classList\n */\nfunction updateClasses(a, b, classList) {\n  var i;\n  var key;\n  var aItem;\n  var bItem;\n  var aLength = a.length;\n  var bLength = b.length;\n  var visited;\n  var removed;\n  var bIndex;\n\n  if (a != null && aLength > 0) {\n    if (b == null || bLength === 0) {\n      // b is empty, remove all classes from a.\n      for (i = 0; i < aLength; i++) {\n        classList.remove(a[i]);\n      }\n    } else {\n      // When lists a and b are small, we are using naive O(M*N) algorithm\n      // to find differences.\n      if (aLength * bLength <= 16) {\n        visited = new Array(bLength);\n\n        for (i = 0; i < aLength; i++) {\n          aItem = a[i];\n          removed = true;\n\n          for (i = 0; i < bLength; i++) {\n            bItem = b[i];\n\n            if (aItem === bItem) {\n              removed = false;\n              visited[i] = true;\n              break;\n            }\n          }\n\n          if (removed) {\n            classList.remove(aItem);\n          }\n        }\n\n        for (i = 0; i < bLength; i++) {\n          if (visited[i] != true) {\n            classList.add(b[i]);\n          }\n        }\n      } else {\n        bIndex = {};\n\n        for (i = 0; i < bLength; i++) {\n          bItem = b[i];\n          bIndex[bItem] = false;\n        }\n\n        for (i = 0; i < aLength; i++) {\n          aItem = a[i];\n          if (aItem === void 0) {\n            classList.remove(aItem);\n          } else {\n            bIndex[aItem] = true;\n          }\n        }\n\n        for (i = 0; i < bLength; i++) {\n          bItem = b[i];\n          if (bIndex[bItem] === false) {\n            classList.add(key);\n          }\n        }\n      }\n    }\n  } else if (b != null && b.length > 0) {\n    // a is empty, insert all classes from b.\n    for (i = 0; i < b.length; i++) {\n      classList.add(b[i]);\n    }\n  }\n}\n\n/**\n * Insert VNode.\n *\n * @param {VNode} parent Parent node.\n * @param {VNode} node Node to insert.\n * @param {HTMLElement} b Reference to the next html element.\n * @param {Context} context Current context.\n */\nfunction insertChild(parent, node, nextRef, context) {\n  if (((parent.flags & V_COMPONENT) === 0) ||\n      ((parent.cref.flags & C_INSERT_HOOK) === 0)) {\n    create(node, context);\n    parent.ref.insertBefore(node.ref, nextRef);\n    render(node, context);\n  } else {\n    parent.cref.descriptor.insert.call(parent.cref, node, nextRef, context);\n  }\n}\n\n/**\n * Move VNode.\n *\n * @param {VNode} parent Parent node.\n * @param {VNode} node Node to move.\n * @param {HTMLElement} b Reference to the next html element.\n * @param {Context} context Current context.\n */\nfunction moveChild(parent, node, nextRef, context) {\n  if (((parent.flags & V_COMPONENT) === 0) ||\n      ((parent.cref.flags & C_MOVE_HOOK) === 0)) {\n    parent.ref.insertBefore(node.ref, nextRef);\n  } else {\n    parent.cref.descriptor.move.call(parent.cref, node, nextRef, context);\n  }\n}\n\n/**\n * Remove VNode.\n *\n * @param {VNode} parent Parent node.\n * @param {VNode} node Node to remove.\n * @param {Context} context Current context.\n */\nfunction removeChild(parent, node, context) {\n  if (((parent.flags & V_COMPONENT) === 0) ||\n      ((parent.cref.flags & C_REMOVE_HOOK) === 0)) {\n    parent.ref.removeChild(node.ref);\n  } else {\n    parent.cref.descriptor.remove.call(parent.cref, node, context);\n  }\n}\n\n/**\n * Update childrens [a] and [b] in the [parent].\n *\n * If one of the childrens has `null` `key`, it will run update\n * algorithm for childrens with implicit keys, otherwise it will run\n * update algorithm for childrens with explicit keys.\n *\n * Mixing childrens with explicit and implicit keys in one children\n * list will result in undefined behaviour. In development mode it\n * will be checked for this conditions and if it is detected that\n * there are childrens with implicit and explicit keys, it will result\n * in runtime error.\n *\n * @param {VNode} parent Childrens parent.\n * @param {Array.<VNode>} a Old children list.\n * @param {Array.<VNode>} b New children list.\n * @param {Context} context Current context.\n */\nfunction updateChildren(parent, a, b, context) {\n  var aNode;\n  var bNode;\n  var i;\n  var unchangedPosition;\n\n  if (a != null && a.length !== 0) {\n    if (b == null || b.length === 0) {\n      // b is empty, remove all children from a.\n      for (i = 0; i < a.length; i++) {\n        removeChild(parent, a[i], context);\n      }\n    } else {\n      if (a.length === 1 && b.length === 1) {\n        // Fast path when a and b have only one child.\n        aNode = a[0];\n        bNode = b[0];\n\n        // Implicit key with same type or explicit key with same key.\n        if ((aNode.key == null && sameType(aNode, bNode)) ||\n            (aNode.key != null && aNode.key === bNode.key)) {\n          update(aNode, bNode, context);\n        } else {\n          removeChild(parent, aNode, context);\n          insertChild(parent, bNode, null, context);\n        }\n      } else if (a.length === 1) {\n        // Fast path when a have 1 child.\n        aNode = a[0];\n        if (aNode.key == null) {\n          updateImplicitChildren(parent, a, b, context);\n        } else {\n          unchangedPosition = -1;\n          for (i = 0; i < b.length; i++) {\n            bNode = b[i];\n            if (aNode.key === bNode.key) {\n              unchangedPosition = i;\n              break;\n            } else {\n              insertChild(parent, bNode, aNode.ref, context);\n            }\n          }\n          if (unchangedPosition !== -1) {\n            for (i = unchangedPosition + 1; i < b.length; i++) {\n              insertChild(parent, b[i], null, context);\n            }\n            update(aNode, b[unchangedPosition], context);\n          } else {\n            removeChild(parent, aNode, context);\n          }\n        }\n      } else if (b.length === 1) {\n        // Fast path when b have 1 child.\n        bNode = b[0];\n        if (bNode.key == null) {\n          updateImplicitChildren(parent, a, b, context);\n        } else {\n          unchangedPosition = -1;\n          for (i = 0; i < a.length; i++) {\n            aNode = a[i];\n            if (aNode.key === bNode.key) {\n              unchangedPosition = i;\n              break;\n            } else {\n              removeChild(parent, aNode, context);\n            }\n          }\n          if (unchangedPosition !== -1) {\n            for (i = unchangedPosition + 1; i < a.length; i++) {\n              removeChild(parent, a[i], context);\n            }\n            update(a[unchangedPosition], bNode, context);\n          } else {\n            insertChild(parent, bNode, null, context);\n          }\n        }\n      } else {\n        // a and b have more than 1 child.\n        if (a[0].key == null) {\n          updateImplicitChildren(parent, a, b, context);\n        } else {\n          updateExplicitChildren(parent, a, b, context);\n        }\n      }\n    }\n  } else if (b != null && b.length > 0) {\n    // a is empty, insert all children from b\n    for (i = 0; i < b.length; i++) {\n      insertChild(parent, b[i], null, context);\n    }\n  }\n}\n\n/**\n * Update childrens with implicit keys `a` and `b` in the `parent`.\n *\n * Any heuristics that is used in this algorithm is an undefined\n * behaviour, and external dependencies should not relay on the\n * knowledge about this algorithm, because it can be changed in any\n * time.\n *\n * @param {VNode} parent Childrens parent.\n * @param {Array.<VNode>} a Old children list.\n * @param {Array.<VNode>} b New children list.\n * @param {Context} context Current context.\n */\nfunction updateImplicitChildren(parent, a, b, context) {\n  var aStart = 0;\n  var bStart = 0;\n  var aEnd = a.length - 1;\n  var bEnd = b.length - 1;\n  var aNode;\n  var bNode;\n  var nextPos;\n  var next;\n\n  // Update nodes with the same type at the beginning.\n  while (aStart <= aEnd && bStart <= bEnd) {\n    aNode = a[aStart];\n    bNode = b[bStart];\n\n    if (!sameType(aNode, bNode)) {\n      break;\n    }\n\n    aStart++;\n    bStart++;\n\n    update(aNode, bNode, context);\n  }\n\n  // Update nodes with the same type at the end.\n  while (aStart <= aEnd && bStart <= bEnd) {\n    aNode = a[aEnd];\n    bNode = b[bEnd];\n\n    if (!sameType(aNode, bNode)) {\n      break;\n    }\n\n    aEnd--;\n    bEnd--;\n\n    update(aNode, bNode, context);\n  }\n\n  // Iterate through the remaining nodes and if they have the same\n  // type, then update, otherwise just remove the old node and insert\n  // the new one.\n  while (aStart <= aEnd && bStart <= bEnd) {\n    aNode = a[aStart++];\n    bNode = b[bStart++];\n    if (sameType(aNode, bNode)) {\n      update(aNode, bNode, context);\n    } else {\n      insertChild(parent, bNode, aNode.ref, context);\n      removeChild(parent, aNode, context);\n    }\n  }\n\n  // All nodes from a are updated, insert the rest from b.\n  while (aStart <= aEnd) {\n    removeChild(parent, a[aStart++], context);\n  }\n\n  nextPos = bEnd + 1;\n  next = nextPos < b.length ? b[nextPos].ref : null;\n\n  // All nodes from b are updated, remove the rest from a.\n  while (bStart <= bEnd) {\n    insertChild(parent, b[bStart++], next, context);\n  }\n}\n\n/**\n * Update childrens with explicit keys [a] and [b] in the [parent].\n *\n * @param {VNode} parent Childrens parent.\n * @param {Array.<VNode>} a Old children list.\n * @param {Array.<VNode>} b New children list.\n * @param {Context} context Current context.\n */\nfunction updateExplicitChildren(parent, a, b, context) {\n  var aStart = 0;\n  var bStart = 0;\n  var aEnd = a.length - 1;\n  var bEnd = b.length - 1;\n  var aStartNode = a[aStart];\n  var bStartNode = b[bStart];\n  var aEndNode = a[aEnd];\n  var bEndNode = b[bEnd];\n  var i;\n  var j;\n  var stop = false;\n  var nextPos;\n  var next;\n  var aNode;\n  var bNode;\n  var lastTarget;\n  var pos;\n  var node;\n\n  // Algorithm that works on simple cases with basic list\n  // transformations.\n  //\n  // It tries to reduce the diff problem by simultaneously iterating\n  // from the beginning and the end of both lists, if keys are the\n  // same, they're updated, if node is moved from the beginnin to the\n  // end of the current cursor positions or vice versa it just\n  // performs move operation and continues to reduce the diff problem.\n  outer: do {\n    stop = true;\n\n    // Update nodes with the same key at the beginning.\n    while (aStartNode.key === bStartNode.key) {\n      update(aStartNode, bStartNode, context);\n      aStart++;\n      bStart++;\n      if (aStart > aEnd || bStart > bEnd) {\n        break outer;\n      }\n      aStartNode = a[aStart];\n      bStartNode = b[bStart];\n      stop = false;\n    }\n\n    // Update nodes with the same key at the end.\n    while (aEndNode.key === bEndNode.key) {\n      update(aEndNode, bEndNode, context);\n      aEnd--;\n      bEnd--;\n      if (aStart > aEnd || bStart > bEnd) {\n        break outer;\n      }\n      aEndNode = a[aEnd];\n      bEndNode = b[bEnd];\n      stop = false;\n    }\n\n    // Move nodes from left to right.\n    while (aStartNode.key === bEndNode.key) {\n      update(aStartNode, bEndNode, context);\n      nextPos = bEnd + 1;\n      next = nextPos < b.length ? b[nextPos].ref : null;\n      moveChild(parent, bEndNode, next, context);\n      aStart++;\n      bEnd--;\n      if (aStart > aEnd || bStart > bEnd) {\n        break outer;\n      }\n      aStartNode = a[aStart];\n      bEndNode = b[bEnd];\n      stop = false;\n    }\n\n    // Move nodes from right to end.\n    while (aEndNode.key === bStartNode.key) {\n      update(aEndNode, bStartNode, context);\n      moveChild(parent, aEndNode, a[aStart].ref, context);\n      aEnd--;\n      bStart++;\n      if (aStart > aEnd || bStart > bEnd) {\n        break outer;\n      }\n      aEndNode = a[aEnd];\n      bStartNode = b[bStart];\n      stop = false;\n    }\n  } while (!stop && aStart <= aEnd && bStart <= bEnd);\n\n  if (aStart > aEnd) {\n    // All nodes from a are updated, insert the rest from b.\n    nextPos = bEnd + 1;\n    next = nextPos < b.length ? b[nextPos].ref : null;\n    while (bStart <= bEnd) {\n      insertChild(parent, b[bStart++], next, context);\n    }\n  } else if (bStart > bEnd) {\n    // All nodes from b are updated, remove the rest from a.\n    while (aStart <= aEnd) {\n      removeChild(parent, a[aStart++], context);\n    }\n  } else {\n    // Perform more complex update algorithm on the remaining nodes.\n    //\n    // We start by marking all nodes from b as inserted, then we try\n    // to find all removed nodes and simultaneously perform updates on\n    // the nodes that exists in both lists and replacing \"inserted\"\n    // marks with the position of the node from the list b in list a.\n    // Then we just need to perform slightly modified LIS algorith,\n    // that ignores \"inserted\" marks and find common subsequence and\n    // move all nodes that doesn't belong to this subsequence, or\n    // insert if they have \"inserted\" mark.\n    var aLength = aEnd - aStart + 1;\n    var bLength = bEnd - bStart + 1;\n    var sources = new Array(bLength);\n\n    // Mark all nodes as inserted.\n    for (i = 0; i < bLength; i++) {\n      sources[i] = -1;\n    }\n\n    var moved = false;\n    var removeOffset = 0;\n\n    // When lists a and b are small, we are using naive O(M*N) algorithm\n    // to find removed children.\n    if (aLength * bLength <= 16) {\n      for (i = aStart; i <= aEnd; i++) {\n        var removed = true;\n        aNode = a[i];\n        for (j = bStart; j <= bEnd; j++) {\n          bNode = b[j];\n          if (aNode.key === bNode.key) {\n            sources[j - bStart] = i;\n\n            if (lastTarget > j) {\n              moved = true;\n            } else {\n              lastTarget = j;\n            }\n            update(aNode, bNode, context);\n            removed = false;\n            break;\n          }\n        }\n        if (removed) {\n          removeChild(parent, aNode, context);\n          removeOffset++;\n        }\n      }\n    } else {\n      var keyIndex = {};\n\n      for (i = bStart; i <= bEnd; i++) {\n        node = b[i];\n        keyIndex[node.key] = i;\n      }\n\n      for (i = aStart; i <= aEnd; i++) {\n        aNode = a[i];\n        j = keyIndex[aNode.key];\n\n        if (j != null) {\n          bNode = b[j];\n          sources[j - bStart] = i;\n          if (lastTarget > j) {\n            moved = true;\n          } else {\n            lastTarget = j;\n          }\n          update(aNode, bNode, context);\n        } else {\n          removeChild(parent, aNode, context);\n          removeOffset++;\n        }\n      }\n    }\n\n    if (moved) {\n      var seq = _lis(sources);\n      // All modifications are performed from the right to left, so we\n      // can use insertBefore method and use reference to the html\n      // element from the next VNode. All Nodes from the right side\n      // should always be in the correct state.\n      j = seq.length - 1;\n      for (i = bLength - 1; i >= 0; i--) {\n        if (sources[i] === -1) {\n          pos = i + bStart;\n          node = b[pos];\n          nextPos = pos + 1;\n          next = nextPos < b.length ? b[nextPos].ref : null;\n          insertChild(parent, node, next, context);\n        } else {\n          if (j < 0 || i != seq[j]) {\n            pos = i + bStart;\n            node = a[sources[i]];\n            nextPos = pos + 1;\n            next = nextPos < b.length ? b[nextPos].ref : null;\n            moveChild(parent, node, next, context);\n          } else {\n            j--;\n          }\n        }\n      }\n    } else if (aLength - removeOffset != bLength) {\n      for (i = bLength - 1; i >= 0; i--) {\n        if (sources[i] === -1) {\n          pos = i + bStart;\n          node = b[pos];\n          nextPos = pos + 1;\n          next = nextPos < b.length ? b[nextPos].ref : null;\n          insertChild(parent, node, next, context);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Slightly modified Longest Increased Subsequence algorithm, it\n * ignores items that have -1 value. They're representing new items.\n *\n * This algorithm is used to find minimum number of move operations\n * when updating childrens with explicit keys.\n *\n * http://en.wikipedia.org/wiki/Longest_increasing_subsequence\n *\n * @param {Array.<number>} a\n * @return {Array.<number>}\n */\nfunction _lis(a) {\n  var p = a.slice(0);\n  var result = [0];\n  var i, il;\n  var j;\n  var u;\n  var v;\n  var c;\n\n  for (i = 0, il = a.length; i < il; i++) {\n    if (a[i] === -1) {\n      continue;\n    }\n\n    j = result[result.length - 1];\n    if (a[j] < a[i]) {\n      p[i] = j;\n      result.push(i);\n      continue;\n    }\n\n    u = 0;\n    v = result.length - 1;\n\n    while (u < v) {\n      c = ((u + v) / 2) | 0;\n      if (a[result[c]] < a[i]) {\n        u = c + 1;\n      } else {\n        v = c;\n      }\n    }\n\n    if (a[i] < a[result[u]]) {\n      if (u > 0) {\n        p[i] = result[u - 1];\n      }\n      result[u] = i;\n    }\n  }\n\n  u = result.length;\n  v = result[u - 1];\n\n  while (u-- > 0) {\n    result[u] = v;\n    v = p[v];\n  }\n\n  return result;\n}\n\n/**\n * Custom Elements\n */\nvar E_INIT_HOOK = 4;\nvar E_UPDATE_HOOK = 8;\n\nfunction declareElement(spec) {\n  var flags = 0;\n  var tag = spec.tag;\n  var init = spec.init;\n  var update = spec.update;\n\n  if (tag === void 0) tag = 'div';\n\n  if (init === void 0) init = null;\n  else flags |= E_INIT_HOOK;\n\n  if (update === void 0) update = null;\n  else flags |= E_UPDATE_HOOK;\n\n  return {\n    flags: flags,\n    tag: tag,\n    init: init,\n    update: update\n  };\n}\n\nfunction createElement(descriptor, data) {\n  var e = document.createElement(descriptor.tag);\n  if ((descriptor.flags & E_INIT_HOOK) !== 0) {\n    descriptor.init.call(e, data);\n  }\n  return e;\n}\n\nfunction updateElement(element, descriptor, oldData, newData) {\n  if ((descriptor.flags & E_UPDATE_HOOK) !== 0) {\n    descriptor.update.call(element, oldData, newData);\n  }\n}\n\n/**\n * Components\n */\nvar C_DIRTY = 1;\nvar C_STATEFUL = 2;\nvar C_DOM_ATTACHED = 4;\nvar C_RENDERED = 8;\nvar C_MOUNTED = 16;\nvar C_UPDATE_PROPS_HOOK = 128;\nvar C_UPDATE_STATE_HOOK = 256;\nvar C_INIT_HOOK = 512;\nvar C_BUILD_HOOK = 1024;\nvar C_ATTACHED_HOOK = 2048;\nvar C_DETACHED_HOOK = 4096;\nvar C_DOM_ATTACHED_HOOK = 8192;\nvar C_DOM_DETACHED_HOOK = 16384;\nvar C_UPDATE_HOOK = 65536;\nvar C_INSERT_HOOK = 262144;\nvar C_MOVE_HOOK = 524288;\nvar C_REMOVE_HOOK = 1048576;\n\n/**\n * Component.\n *\n * @param {!Object} descriptor Component descriptor object.\n * @param {!Component} parent Parent component.\n * @param {Object} data Component data.\n * @final\n * @constructor\n * @struct\n */\nfunction Component(descriptor, parent, props) {\n  var flags = descriptor.flags;\n\n  /**\n   * Component flags.\n   * @type {number}\n   */\n  this.flags = flags | C_DIRTY;\n\n  /**\n   * ComponentDescriptor.\n   * @type {!Object}\n   */\n  this.descriptor = descriptor;\n\n  /**\n   * Depth relative to other Components.\n   * @type {number}\n   */\n  this.depth = parent == null ? 0 : parent.depth + 1;\n\n  /**\n   * Parent Component.\n   * @type {Component}\n   */\n  this.parent = parent;\n\n  this.props = props;\n\n  /**\n   * Component State.\n   * @type {!DNode}\n   */\n  if ((flags & C_UPDATE_STATE_HOOK) === 0) {\n    this.state = null;\n  } else {\n    this.state = DNode.create();\n    this.state.invalidated = this.invalidate;\n    this.state.ctx = this;\n  }\n\n  this.rev = -1;\n\n  /**\n   * Root node in the Components virtual tree.\n   * @type {VNode}\n   */\n  this.root = null;\n\n  /**\n   * Reference to the Html Element.\n   * @type {HTMLElement}\n   */\n  this.element = document.createElement(descriptor.tag);\n\n  /**\n   * updateLater bound method.\n   * @type {function(this:!Component)}\n   */\n  this._update = null;\n\n  if ((flags & C_INIT_HOOK) !== 0) {\n    descriptor.init.call(this);\n  }\n}\n\n/**\n * Create Component Descriptor Object\n * @nosideeffects\n * @param {!Object} decl Component declaration\n * @return {!Object}\n */\nfunction declareComponent(spec) {\n  var flags = 0|0;\n  var tag = spec.tag;\n  var updateProps = spec.updateProps;\n  var updateState = spec.updateState;\n  var init = spec.init;\n  var build = spec.build;\n  var attached = spec.attached;\n  var detached = spec.detached;\n  var domAttached = spec.domAttached;\n  var domDetached = spec.domDetached;\n  var update = spec.update;\n  var insert = spec.insert;\n  var move = spec.move;\n  var remove = spec.remove;\n\n  if (tag === void 0) tag = 'div';\n\n  if (updateProps === void 0) updateProps = null;\n  else flags |= C_UPDATE_PROPS_HOOK;\n\n  if (updateState === void 0) updateState = null;\n  else flags |= C_STATEFUL | C_UPDATE_STATE_HOOK;\n\n  if (init === void 0) init = null;\n  else flags |= C_INIT_HOOK;\n\n  if (build === void 0) build = null;\n  else flags |= C_BUILD_HOOK;\n\n  if (attached === void 0) attached = null;\n  else flags |= C_ATTACHED_HOOK;\n\n  if (detached === void 0) detached = null;\n  else flags |= C_DETACHED_HOOK;\n\n  if (domAttached === void 0) domAttached = null;\n  else flags |= C_DOM_ATTACHED_HOOK;\n\n  if (domDetached === void 0) domDetached = null;\n  else flags |= C_DOM_DETACHED_HOOK;\n\n  if (update === void 0) update = null;\n  else flags |= C_UPDATE_HOOK;\n\n  if (insert === void 0) insert = null;\n  else flags |= C_INSERT_HOOK;\n\n  if (move === void 0) move = null;\n  else flags |= C_MOVE_HOOK;\n\n  if (remove === void 0) remove = null;\n  else flags |= C_REMOVE_HOOK;\n\n  return {\n    flags: flags,\n    updateProps: updateProps,\n    updateState: updateState,\n    init: init,\n    build: build,\n    attached: attached,\n    detached: detached,\n    domAttached: domAttached,\n    domDetached: domDetached,\n    update: update,\n    insert: insert,\n    move: move,\n    remove: remove,\n    tag: tag\n  };\n};\n\nfunction createComponent(descriptor, props, ctx) {\n  return new Component(descriptor, ctx, props);\n};\n\nComponent.prototype.domAttach = function() {};\nComponent.prototype.domDetach = function() {};\nComponent.prototype.attach = function() {};\nComponent.prototype.detach = function() {};\n\nComponent.prototype.updateProps = function(props) {\n  if ((this.flags & C_UPDATE_PROPS_HOOK) !== 0) {\n    if (this.descriptor.updateProps.call(this, props)) {\n      this.flags |= C_DIRTY;\n    }\n  } else {\n    // TODO: shallow equal check by default\n    this.props = props;\n    this.flags |= C_DIRTY;\n  }\n};\n\nComponent.prototype.update = function() {\n  var flags = this.flags;\n\n  if ((flags & C_DIRTY) !== 0) {\n    var descriptor = this.descriptor;\n\n    if ((flags & C_UPDATE_HOOK) === 0) {\n      if ((flags & C_UPDATE_STATE_HOOK) !== 0) {\n        descriptor.updateState.call(this);\n        if (this.rev < this.state.rev) {\n          this.updateView(descriptor.build.call(this));\n        }\n      } else {\n        this.updateView(descriptor.build.call(this));\n      }\n      this.flags &= ~C_DIRTY;\n    } else {\n      descriptor.update.call(this);\n    }\n    this.rev = ENV.scheduler.clock;\n  }\n};\n\nComponent.prototype.updateView = function(newRoot) {\n  var root = this.root;\n\n  if (root == null) {\n    newRoot.ref = this.element;\n    newRoot.cref = this;\n    render(newRoot, this);\n  } else {\n    update(root, newRoot, this);\n  }\n  this.root = newRoot;\n};\n\nComponent.prototype.invalidate = function() {\n  if ((this.flags & C_DIRTY) === 0) {\n    this.flags |= C_DIRTY;\n    if (this._update == null) {\n      this._update = this.update.bind(this);\n    }\n\n    ENV.scheduler.nextFrame().write(this._update, this.depth);\n  }\n};\n\nComponent.prototype.dispose = function() {\n  if ((this.flags & C_STATEFUL) !== 0) {\n    this.state.dispose();\n  }\n};\n\nfunction injectComponent(component, parent) {\n  parent.appendChild(component.element);\n  component.attach();\n  component.domAttach();\n  component.update();\n};\n\nmodule.exports = {\n  VNode: VNode,\n  Component: Component,\n  declareElement: declareElement,\n  declareComponent: declareComponent,\n  create: create,\n  render: render,\n  update: update,\n  createComponent: createComponent,\n  t: text,\n  $t: $text,\n  e: element,\n  $e: $element,\n  d: customElement,\n  $d: $customElement,\n  s: svg,\n  $s: $svg,\n  c: component,\n  $c: $component,\n  r: root,\n  injectComponent: injectComponent\n};\n","'use strict';\n\nvar app = {\n  store: null,\n  cache: null\n};\n\nmodule.exports = app;\n","'use strict';\n\nvar kivi = require('kivi');\nvar DNode = kivi.DNode;\n\nvar app = require('./app');\n\nvar DatabaseCache = function() {\n  this._queries = {};\n};\n\nDatabaseCache.prototype.getTopFiveQueries = function(id) {\n  var qs = this._queries[id];\n  if (qs === void 0) {\n    qs = DNode.create();\n    this._queries[id] = qs;\n  }\n\n  if (qs.dirty) {\n    var db = app.store.get(id);\n    qs.sub(db);\n\n    var queries = db.data.queries.slice();\n    queries.sort(function(a, b) {\n      return a.elapsed - b.elapsed;\n    });\n    queries = queries.slice(0, 5);\n    while (queries.length < 5) {\n      queries.push({\n        canvas_action: null,\n        canvas_context_id: null,\n        canvas_controller: null,\n        canvas_hostname: null,\n        canvas_job_tag: null,\n        canvas_pid: null,\n        elapsed: 0,\n        query: '',\n        waiting: 0\n      });\n    }\n\n    qs.data = queries;\n    qs.update(true);\n  }\n\n  return qs;\n};\n\nmodule.exports = DatabaseCache;\n","'use strict';\n\nvar kivi = require('kivi');\nvar vdom = kivi.vdom;\n\nvar app = require('../app');\nvar Popover = require('./popover');\n\nfunction _formatElapsed(v) {\n  if (!v) return '';\n\n  var str = parseFloat(v).toFixed(2);\n\n  if (v > 60) {\n    var minutes = Math.floor(v / 60);\n    var comps = (value % 60).toFixed(2).split('.');\n    var seconds = comps[0].lpad('0', 2);\n    var ms = comps[1];\n    str = minutes + \":\" + seconds + \".\" + ms;\n  }\n\n  return str;\n}\n\nvar _IMPORTANT_CLASS = ['label-important'];\nvar _WARNING_CLASS = ['label-warning'];\nvar _SUCCESS_CLASS = ['label-success'];\n\nvar Entry = vdom.declareComponent({\n  tag: 'tr',\n\n  updateState: function() {\n    var queries = app.cache.getTopFiveQueries(this.props.db.data.id);\n    this.state.sub(queries);\n    this.state.data = {\n      topFiveQueries: queries.data\n    };\n    this.state.update(true);\n  },\n\n  build: function() {\n    var db = this.props.db.data;\n    var topFiveQueries = this.state.data.topFiveQueries;\n\n    var name = vdom.e('td');\n    name.type = 'dbname';\n    name.children = [vdom.t(db.name)];\n\n    var count = db.queries.length;\n\n    var qcSpan = vdom.e('span');\n    qcSpan.type = 'label';\n    qcSpan.children = [vdom.t(count)];\n    if (count >= 20) {\n      qcSpan.classes = _IMPORTANT_CLASS;\n    } else if (count >= 10) {\n      qcSpan.classes = _WARNING_CLASS;\n    } else {\n      qcSpan.classes = _SUCCESS_CLASS;\n    }\n\n    var qc = vdom.e('td');\n    qc.type = 'query-count';\n    qc.children = [qcSpan];\n\n    var children = [name, qc];\n\n    for (var i = 0; i < 5; i++) {\n      var q = topFiveQueries[i];\n      var elapsed = q.elapsed;\n      var text = vdom.t(_formatElapsed(elapsed));\n      var popover = vdom.c(Popover, {query: q.query});\n\n      var col = vdom.e('td');\n      col.type = 'Query';\n      col.classes = ['elapsed'];\n      if (elapsed >= 10.0) {\n        col.classes.push('warn_long');\n      } else if (elapsed >= 1.0) {\n        col.classes.push('warn');\n      } else {\n        col.classes.push('short');\n      }\n      col.children = [text, popover];\n      children.push(col);\n    }\n\n    var root = vdom.r();\n    root.children = children;\n    return root;\n  }\n});\n\nmodule.exports = Entry;","'use strict';\n\nvar kivi = require('kivi');\nvar vdom = kivi.vdom;\n\nvar app = require('../app');\nvar Entry = require('./entry');\n\nvar _ROOT_CLASSES = ['table', 'table-striped', 'latest-data'];\n\nvar Main = vdom.declareComponent({\n  tag: 'table',\n\n  updateState: function() {\n    var dbs = app.store.getAll();\n    this.state.sub(dbs);\n    this.state.data = dbs.data;\n    this.state.update(true);\n  },\n\n  build: function() {\n    var dbs = this.state.data;\n\n    var rows = [];\n    for (var i = 0; i < dbs.length; i++) {\n      var db = dbs[i];\n      rows.push(vdom.$c(db.data.id, Entry, {db: db}));\n    }\n\n    var tbody = vdom.e('tbody');\n    tbody.children = rows;\n\n    var root = vdom.r();\n    root.classes = _ROOT_CLASSES;\n    root.children = [tbody];\n\n    return root;\n  }\n});\n\nmodule.exports = Main;\n","'use strict';\n\nvar kivi = require('kivi');\nvar vdom = kivi.vdom;\n\nvar _ROOT_CLASSES = ['popover', 'left'];\n\nvar Popover = vdom.declareComponent({\n  build: function() {\n    var content = vdom.e('div');\n    content.type = 'popover-content';\n    content.children = [vdom.t(this.props.query)];\n\n    var arrow = vdom.e('div');\n    arrow.type = 'arrow';\n\n    var root = vdom.r();\n    root.classes = _ROOT_CLASSES;\n    root.children = [content, arrow];\n\n    return root;\n  }\n});\n\nmodule.exports = Popover;\n","'use strict';\n\nvar kivi = require('kivi');\nvar DNode = kivi.DNode;\n\nvar _nextId = 0;\n\nfunction DatabaseStore(n) {\n  var dbs = [];\n\n  for (var i = 0; i < n; i++) {\n    dbs.push(DNode.create({\n      id: _nextId++,\n      name: 'cluster' + i,\n      queries: null\n    }));\n    dbs.push(DNode.create({\n      id: _nextId++,\n      name: 'cluster' + i + 'slave',\n      queries: null\n    }));\n  }\n\n  this._dbs = DNode.create(dbs);\n  this.update();\n}\n\nDatabaseStore.prototype.getAll = function() {\n  return this._dbs;\n};\n\nDatabaseStore.prototype.get = function(id) {\n  return this._dbs.data[id];\n};\n\nDatabaseStore.prototype.update = function() {\n  var dbs = this._dbs.data;\n\n  for (var i = 0; i < dbs.length; i++) {\n    var db = dbs[i];\n\n    var queries = [];\n\n    var r = Math.floor((Math.random() * 10) + 1);\n    for (var j = 0; j < r; j++) {\n      var q = {\n        canvas_action: null,\n        canvas_context_id: null,\n        canvas_controller: null,\n        canvas_hostname: null,\n        canvas_job_tag: null,\n        canvas_pid: null,\n        elapsed: Math.random() * 15,\n        query: 'SELECT blah FROM something',\n        waiting: Math.random() < 0.5\n      };\n\n      if (Math.random() < 0.2) {\n        q.query = '<IDLE> in transaction';\n      }\n\n      if (Math.random() < 0.1) {\n        q.query = 'vacuum';\n      }\n\n      queries.push(q);\n    }\n    db.data.queries = queries;\n    db.commit();\n  }\n};\n\nmodule.exports = DatabaseStore;"]}